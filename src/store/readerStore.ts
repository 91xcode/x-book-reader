import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { FoliateView } from '@/types/view';
import { ViewSettings, TOCItem, Location, Book, BookDoc, PageInfo, TimeInfo } from '@/types/book';
import { DEFAULT_VIEW_SETTINGS } from '@/utils/constants';
import { getCompleteStyles } from '@/utils/style';
import { useBookDataStore } from './bookDataStore';
import { BookServiceV2 } from '@/services/BookServiceV2';
import { DocumentLoader } from '@/libs/document';

interface Progress {
  cfi?: string;
  tocItem?: TOCItem;
  location?: Location;
  time?: number;
  range?: Range;
  sectionHref?: string;
  sectionLabel?: string;
  sectionId?: number;
  section?: PageInfo;
  pageinfo?: PageInfo;
  timeinfo?: TimeInfo;
}

interface ViewState {
  key: string;
  view: FoliateView | null;
  isPrimary: boolean;
  loading: boolean;
  error: string | null;
  progress: Progress | null;
  ribbonVisible: boolean;
  ttsEnabled: boolean;
  gridInsets: any | null;
  viewSettings: ViewSettings | null;
}

interface ReaderState {
  // ËßÜÂõæÁÆ°ÁêÜ
  views: Record<string, FoliateView | null>;
  viewStates: Record<string, ViewState>;
  
  // ËßÜÂõæËÆæÁΩÆ
  viewSettings: Record<string, ViewSettings>;
  
  // ËøõÂ∫¶ÁÆ°ÁêÜ
  progress: Record<string, Progress>;
  
  // Â∑•ÂÖ∑Ê†èÁä∂ÊÄÅ - readestÈ£éÊ†º
  hoveredBookKey: string | null;
  
  // ‰π¶Á±çÈîÆÂàóË°®
  bookKeys: string[];
  
  // Actions
  setView: (bookKey: string, view: FoliateView | null) => void;
  getView: (bookKey: string) => FoliateView | null;
  
  // Â∑•ÂÖ∑Ê†èÁä∂ÊÄÅÁÆ°ÁêÜ - readestÈ£éÊ†º
  setHoveredBookKey: (bookKey: string | null) => void;
  getHoveredBookKey: () => string | null;
  getViewsById: (bookId: string) => (FoliateView | null)[];
  
  setViewSettings: (bookKey: string, settings: ViewSettings) => void;
  getViewSettings: (bookKey: string) => ViewSettings | null;
  initializeViewSettings: (bookKey: string) => void;
  applyViewStyles: (bookKey: string) => void;
  
  setProgress: (
    bookKey: string,
    cfi?: string,
    tocItem?: TOCItem,
    section?: PageInfo,
    pageinfo?: PageInfo,
    timeinfo?: TimeInfo,
    location?: Location,
    time?: number,
    range?: Range,
  ) => void;
  getProgress: (bookKey: string) => Progress | null;
  
  addBookKey: (bookKey: string) => void;
  removeBookKey: (bookKey: string) => void;
  clearBookKeys: () => void;

  // New methods to match readest
  setBookKeys: (keys: string[]) => void;
  getViewState: (key: string) => ViewState | null;
  initViewState: (id: string, key: string, isPrimary?: boolean) => Promise<void>;
  clearViewState: (key: string) => void;
}

export const useReaderStore = create<ReaderState>()(
  persist(
    (set, get) => ({
  views: {},
  viewStates: {},
  
  // Â∑•ÂÖ∑Ê†èÁä∂ÊÄÅ - readestÈ£éÊ†º  
  hoveredBookKey: null,
  viewSettings: {},
  progress: {},
  bookKeys: [],

  setView: (bookKey: string, view: FoliateView | null) => {
    set((state) => ({
      views: {
        ...state.views,
        [bookKey]: view,
      },
      viewStates: {
        ...state.viewStates,
        [bookKey]: {
          ...state.viewStates[bookKey],
          view,
        },
      },
    }));
  },

  getView: (bookKey: string) => {
    return get().views[bookKey] || null;
  },

  // üéØ Â∑•ÂÖ∑Ê†èÁä∂ÊÄÅÁÆ°ÁêÜ - readestÈ£éÊ†º
  setHoveredBookKey: (bookKey: string | null) => {
    set({ hoveredBookKey: bookKey });
  },

  getHoveredBookKey: () => {
    return get().hoveredBookKey;
  },

  getViewsById: (bookId: string) => {
    const state = get();
    return state.bookKeys
      .filter(key => key.startsWith(bookId))
      .map(key => state.views[key] || null);
  },

  setViewSettings: (bookKey: string, settings: ViewSettings) => {
    set((state) => ({
      viewSettings: {
        ...state.viewSettings,
        [bookKey]: settings,
      },
    }));
    
    console.log('üìö Store: Êõ¥Êñ∞viewSettings', {
      bookKey,
      fontSize: settings.defaultFontSize,
      overrideFont: settings.overrideFont
    });
  },

  getViewSettings: (bookKey: string) => {
    return get().viewSettings[bookKey] || null;
  },

  initializeViewSettings: (bookKey: string) => {
    const currentSettings = get().viewSettings[bookKey];
    if (!currentSettings) {
      // Ëé∑ÂèñÂÖ®Â±ÄËÆæÁΩÆ - Áõ¥Êé•‰ªéDEFAULT_VIEW_SETTINGSÊûÑÂª∫ÔºåÈÅøÂÖçÂæ™ÁéØ‰æùËµñ
      const globalViewSettings = {}; // ÊöÇÊó∂‰∏∫Á©∫ÂØπË±°ÔºåÂêéÁª≠ÂèØ‰ª•ÈÄöËøáÂèÇÊï∞‰º†ÂÖ•
      
      // ‰∏éreadestÂÆåÂÖ®‰∏ÄËá¥ÁöÑÂêàÂπ∂ÈÄªËæë
      const isCJKEnv = () => {
        if (typeof window === 'undefined') return false;
        const lang = navigator.language || 'en';
        return ['zh', 'ja', 'ko'].some(l => lang.startsWith(l));
      };
      
      const mergedSettings = {
        ...DEFAULT_VIEW_SETTINGS,
        ...(isCJKEnv() ? { fullJustification: true, textIndent: 2 } : {}), // CJKÁéØÂ¢ÉÁâπÊÆäÂ§ÑÁêÜ
        ...globalViewSettings
      };
      
      console.log('üîß ÂàùÂßãÂåñviewSettings:', {
        isCJK: isCJKEnv(),
        textIndent: mergedSettings.textIndent,
        overrideLayout: mergedSettings.overrideLayout,
        fullSettings: mergedSettings
      });
      
      set((state) => ({
        viewSettings: {
          ...state.viewSettings,
          [bookKey]: mergedSettings,
        },
      }));
      
      // Á´ãÂç≥Â∫îÁî®Ê†∑Âºè
      const view = get().views[bookKey];
      if (view?.renderer?.setStyles) {
        view.renderer.setStyles(getCompleteStyles(mergedSettings));
      }
    }
  },

  applyViewStyles: (bookKey: string) => {
    const state = get();
    const view = state.views[bookKey];
    const settings = state.viewSettings[bookKey];
    
    if (!view || !settings) return;
    
    try {
      // Apply styles - ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂÆûÈôÖÂ∫îÁî®Ê†∑ÂºèÂà∞iframe
      const styles = getCompleteStyles(settings);
      
      console.log('üé® Store: Â∫îÁî®Ê†∑ÂºèÂà∞iframe', {
        bookKey,
        stylesLength: styles.length,
        fontSize: settings.defaultFontSize,
        overrideFont: settings.overrideFont
      });
      
      // ÂÆûÈôÖÂ∫îÁî®Ê†∑ÂºèÂà∞iframe
      if (view.renderer?.setStyles) {
        view.renderer.setStyles(styles);
        console.log('‚úÖ Store: Ê†∑ÂºèÂ∑≤ÊàêÂäüÂ∫îÁî®Âà∞iframe');
      } else {
        // Store styles for later application when docs are loaded
        (view as any)._pendingStyles = styles;
        console.log('üìù Store: Ê†∑ÂºèÂ∑≤ÊöÇÂ≠òÔºåÁ≠âÂæÖiframeÂáÜÂ§áÂ∞±Áª™');
      }
      
      // Apply layout properties to renderer
      if (view.renderer) {
        const { renderer } = view;
        
        // Apply margins
        renderer.setAttribute('margin-top', `${settings.marginTopPx}px`);
        renderer.setAttribute('margin-bottom', `${settings.marginBottomPx}px`);
        renderer.setAttribute('margin-left', `${settings.marginLeftPx}px`);
        renderer.setAttribute('margin-right', `${settings.marginRightPx}px`);
        
        // Apply gap
        renderer.setAttribute('gap', `${settings.gapPercent}%`);
        
        // Apply column settings
        renderer.setAttribute('max-column-count', settings.maxColumnCount.toString());
        renderer.setAttribute('max-inline-size', `${settings.maxInlineSize}px`);
        renderer.setAttribute('max-block-size', `${settings.maxBlockSize}px`);
        
        // Apply flow mode
        renderer.setAttribute('flow', settings.scrolled ? 'scrolled' : 'paginated');
        
        // Apply writing mode
        if (settings.writingMode !== 'auto') {
          renderer.setAttribute('writing-mode', settings.writingMode);
        }
        
        // üéØ Apply animation - readestÈ£éÊ†º
        if (settings.animated) {
          renderer.setAttribute('animated', '');
        } else {
          renderer.removeAttribute('animated');
        }
      }
    } catch (error) {
      console.error('Failed to apply view styles:', error);
    }
  },

  setProgress: (
    bookKey: string,
    cfi?: string,
    tocItem?: TOCItem,
    section?: PageInfo,
    pageinfo?: PageInfo,
    timeinfo?: TimeInfo,
    location?: Location,
    time?: number,
    range?: Range,
  ) => {
    set((state) => ({
      progress: {
        ...state.progress,
        [bookKey]: {
          cfi,
          tocItem,
          section,
          pageinfo,
          timeinfo,
          location,
          time: time || Date.now(),
          range,
          sectionHref: tocItem?.href,
          sectionLabel: tocItem?.label,
          sectionId: tocItem?.id,
        },
      },
    }));
  },

  getProgress: (bookKey: string) => {
    return get().progress[bookKey] || null;
  },

  addBookKey: (bookKey: string) => {
    set((state) => ({
      bookKeys: state.bookKeys.includes(bookKey) 
        ? state.bookKeys 
        : [...state.bookKeys, bookKey],
    }));
  },

  removeBookKey: (bookKey: string) => {
    set((state) => ({
      bookKeys: state.bookKeys.filter(key => key !== bookKey),
      views: Object.fromEntries(
        Object.entries(state.views).filter(([key]) => key !== bookKey)
      ),
      viewSettings: Object.fromEntries(
        Object.entries(state.viewSettings).filter(([key]) => key !== bookKey)
      ),
      progress: Object.fromEntries(
        Object.entries(state.progress).filter(([key]) => key !== bookKey)
      ),
    }));
  },

  clearBookKeys: () => {
    set({
      bookKeys: [],
      views: {},
      viewSettings: {},
      progress: {},
    });
  },

  // New methods to match readest
  setBookKeys: (keys: string[]) => set({ bookKeys: keys }),

  getViewState: (key: string) => get().viewStates[key] || null,

  initViewState: async (id: string, key: string, isPrimary = true) => {
    const startTime = performance.now();
    console.log('üöÄ ReaderStore: ÂàùÂßãÂåñViewState', { id, key, isPrimary });
    
    // ËÆæÁΩÆÂàùÂßãÂä†ËΩΩÁä∂ÊÄÅ
    set((state) => ({
      viewStates: {
        ...state.viewStates,
        [key]: {
          key,
          view: null,
          isPrimary,
          loading: true,
          error: null,
          progress: null,
          ribbonVisible: false,
          ttsEnabled: false,
          gridInsets: null,
          viewSettings: null,
        },
      },
    }));

    try {
      const bookDataStore = useBookDataStore.getState();
      const bookService = BookServiceV2.getInstance();
      
      // Ê£ÄÊü•ÁºìÂ≠ò‰∏≠ÊòØÂê¶Â∑≤ÊúâÊï∞ÊçÆ
      let bookData = bookDataStore.getBookData(id);
      
      if (!bookData?.bookDoc) {
        console.log('üìö ReadestÁ≠ñÁï•ÔºöÁºìÂ≠ò‰∏≠Ê≤°ÊúâBookDocÔºåÂºÄÂßãÂª∂ËøüËß£Êûê...');
        
        // ‰ªébookServiceËé∑Âèñ‰π¶Á±çÂÖÉÊï∞ÊçÆ
        const book = bookService.getBookByHash(id);
        if (!book) {
          throw new Error('Book not found');
        }
        
        // Ëé∑Âèñ‰π¶Á±çÊñá‰ª∂
        const bookFile = await bookService.getBookFile(book.hash);
        if (!bookFile) {
          throw new Error('Êó†Ê≥ïÂä†ËΩΩ‰π¶Á±çÊñá‰ª∂');
        }
        
        // Ê£ÄÊü•ÁºìÂ≠òÊòØÂê¶ÊúâÊïà
        if (bookData && bookDataStore.isCacheValid(id, bookFile)) {
          console.log('‚úÖ ‰ΩøÁî®ÊúâÊïàÁºìÂ≠ò');
        } else {
          console.log('üìñ Ëß£Êûê‰π¶Á±çÊñáÊ°£...');
          // Ëß£Êûê‰π¶Á±çÊñáÊ°£
          const loader = new DocumentLoader(bookFile);
          const parsedDocument = await loader.open();
          
          if (!parsedDocument?.book) {
            throw new Error('Êó†Ê≥ïËß£Êûê‰π¶Á±çÂÜÖÂÆπ');
          }
          
          // ÁºìÂ≠òËß£ÊûêÂêéÁöÑÊï∞ÊçÆ
          bookDataStore.setBookData(id, {
            id,
            book,
            file: bookFile,
            config: null, // ÈÖçÁΩÆÂ∞ÜÂú®ÈúÄË¶ÅÊó∂ËÆæÁΩÆ
            bookDoc: parsedDocument.book,
            fileLastModified: bookFile.lastModified,
          });
          
          bookData = bookDataStore.getBookData(id);
        }
      } else {
        console.log('üöÄ ‰ΩøÁî®ÁºìÂ≠òÁöÑ‰π¶Á±çÊï∞ÊçÆ - Âø´ÈÄüÂä†ËΩΩÊ®°Âºè (SPAÂØºËà™‰øùÊåÅÂÜÖÂ≠òÁä∂ÊÄÅ)');
      }
      
      if (!bookData?.bookDoc) {
        throw new Error('Failed to load book data');
      }
      
      // ÂàùÂßãÂåñËßÜÂõæËÆæÁΩÆ
      const currentSettings = get().viewSettings[key];
      if (!currentSettings) {
        get().initializeViewSettings(key);
      }
      
      // Êõ¥Êñ∞ViewState‰∏∫ÊàêÂäüÁä∂ÊÄÅ
      set((state) => ({
        viewStates: {
          ...state.viewStates,
          [key]: {
            ...state.viewStates[key]!,
            loading: false,
            error: null,
            viewSettings: state.viewSettings[key],
          },
        },
      }));
      
      const endTime = performance.now();
      const duration = endTime - startTime;
      console.log('‚úÖ ViewStateÂàùÂßãÂåñÂÆåÊàê', { 
        key, 
        hasBookDoc: !!bookData.bookDoc,
        duration: `${duration.toFixed(2)}ms`,
        fromCache: !!bookData.bookDoc
      });
      
    } catch (error) {
      console.error('‚ùå ViewStateÂàùÂßãÂåñÂ§±Ë¥•:', error);
      
      set((state) => ({
        viewStates: {
          ...state.viewStates,
          [key]: {
            ...state.viewStates[key]!,
            loading: false,
            error: error instanceof Error ? error.message : 'Failed to load book.',
          },
        },
      }));
    }
  },

  clearViewState: (key: string) => {
    set((state) => {
      const viewStates = { ...state.viewStates };
      delete viewStates[key];
      return { viewStates };
    });
  },

  }),
  {
    name: 'reader-store',
    partialize: (state) => ({
      viewSettings: state.viewSettings,
      progress: state.progress,
    }),
    // Skip hydration to prevent initial render issues
    skipHydration: true,
  }
  )
);  